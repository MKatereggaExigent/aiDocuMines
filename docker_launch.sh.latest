#!/usr/bin/env bash

set -e  # Stop on any error

echo "üõë Stopping any non-Docker processes using relevant ports..."
PORTS=(8020 6381 15672 8050)  # Exclude Docker-managed ports like 5432 (PostgreSQL) and 6379 (Redis)

for PORT in "${PORTS[@]}"; do
    PIDS=$(lsof -t -i:$PORT || true)
    if [[ ! -z "$PIDS" ]]; then
        echo "üî™ Killing processes on port $PORT: $PIDS..."
        for PID in $PIDS; do
            kill -9 "$PID" 2>/dev/null || echo "‚ö†Ô∏è  Failed to kill PID $PID"
        done
    else
        echo "‚úÖ No process running on port $PORT."
    fi
done

# 1Ô∏è‚É£ **Ensure Docker is Running**
if ! docker info >/dev/null 2>&1; then
    echo "‚ùå ERROR: Docker is not running. Please start Docker and try again."
    exit 1
fi

# ‚≠êÔ∏è NEW (ROBUST): EXPORT VARIABLES FROM .env ‚≠êÔ∏è
# This makes the variables in .env available to the shell, so Docker Compose
# can correctly substitute them for the 'db' service.
if [ -f .env ]; then
  echo "üì¶ Reading and exporting variables from .env for local execution..."
  # This loop is more robust than 'xargs' and handles special characters in passwords.
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Ignore comments and empty lines
    if [[ ! "$line" =~ ^# ]] && [[ -n "$line" ]]; then
      export "$line"
    fi
  done < .env
  echo "‚úÖ Variables exported from .env."

  # --- DEBUGGING STEP 1: Check variables after export ---
  echo
  echo "üîç DEBUG: Checking variables immediately after export:"
  echo "  - POSTGRES_USER=${POSTGRES_USER}"
  echo "  - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
  echo "  - POSTGRES_DB=${POSTGRES_DB}"
  echo "----------------------------------------------------"
  echo

else
  echo "‚ö†Ô∏è Warning: .env file not found. The 'db' service may fail to start correctly."
fi

echo "üßπ Cleaning up Docker environment..."
docker-compose down -v --remove-orphans || echo "‚ö†Ô∏è Warning: Failed to bring down containers."
docker system prune -af || echo "‚ö†Ô∏è Warning: Failed to prune unused images and containers."
docker volume prune -af || echo "‚ö†Ô∏è Warning: Failed to prune unused volumes."

echo "üöÄ Starting Docker containers..."
echo
echo "üîç DEBUG: Variables just before 'docker-compose up':"
echo "  - POSTGRES_USER=${POSTGRES_USER}"
echo "  - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
echo "----------------------------------------------------"
echo

docker-compose build || { echo "‚ùå ERROR: Build failed!"; exit 1; }
docker-compose up --build || { echo "‚ùå ERROR: Failed to start containers!"; exit 1; }

# --- DEBUGGING STEP 2: Check environment inside the running container ---
echo
echo "üîç DEBUG: Checking environment variables INSIDE the running 'db' container..."
# Wait a few seconds for the container to initialize its process
sleep 5
docker exec aidocumines_api_layer_db env | grep POSTGRES || echo "‚ö†Ô∏è Could not inspect environment of db container."
echo "----------------------------------------------------"
echo

# 2Ô∏è‚É£ **Wait for PostgreSQL & Redis to be Healthy**
echo "‚è≥ Waiting for services to be healthy..."
TRIES=20
while [[ $TRIES -gt 0 ]]; do
    # Using the correct container name for the database
    DB_STATUS=$(docker inspect --format='{{.State.Health.Status}}' aidocumines_api_layer_db 2>/dev/null || echo "unhealthy")
    REDIS_STATUS=$(docker inspect --format='{{.State.Health.Status}}' aidocumines_redis 2>/dev/null || echo "unhealthy")

    if [[ "$DB_STATUS" == "healthy" && "$REDIS_STATUS" == "healthy" ]]; then
        echo "‚úÖ Database and Redis are healthy!"
        break
    fi

    echo "‚è≥ Waiting... DB: $DB_STATUS, Redis: $REDIS_STATUS ($TRIES retries left)"
    ((TRIES--))
    sleep 3
done

if [[ "$DB_STATUS" != "healthy" || "$REDIS_STATUS" != "healthy" ]]; then
    echo "‚ùå ERROR: Database or Redis did not become healthy in time!"
    echo "--- LOGS FOR aidocumines_api_layer_db ---"
    docker logs aidocumines_api_layer_db || echo "‚ö†Ô∏è Could not retrieve DB logs."
    echo "--- LOGS FOR aidocumines_redis ---"
    docker logs aidocumines_redis || echo "‚ö†Ô∏è Could not retrieve Redis logs."
    echo "--- LOGS FOR aidocumines_db_prepare (where the error likely occurs) ---"
    docker logs aidocumines_db_prepare || echo "‚ö†Ô∏è Could not retrieve db_prepare logs."
    exit 1
fi

echo "‚úÖ All services started successfully!"

