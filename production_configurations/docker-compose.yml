# ====================================================================================
# Azure Production docker-compose.yml (Template)
#
# IMPORTANT: This file is a TEMPLATE for configuring your services in Azure.
# You will NOT run 'docker-compose up' with this file in production.
# Instead, you will:
#   1. Build your custom images (web, celery, etc.) and push them to a registry
#      like Azure Container Registry (ACR).
#   2. Provision managed Azure services for PostgreSQL, Redis, and blob storage.
#   3. Deploy your custom containers using a service like Azure Container Apps or
#      Azure App Service, injecting the environment variables from Azure Key Vault.
# ====================================================================================

version: "3.8"

services:
  # ------------------------------------------------------------------------------------
  # ⭐️ RECOMMENDED: Replace with Azure Database for PostgreSQL (Managed Service)
  # Running a database in a container is not recommended for production due to data
  # persistence, backup, and scaling challenges.
  # ------------------------------------------------------------------------------------
  db:
    image: postgres:15 # In Azure, you would provision a managed PostgreSQL instance.
    container_name: aidocumines-api-layer-db
    restart: unless-stopped
    # 'environment' is the key change. These variables will be injected by Azure
    # from Azure Key Vault, not from an .env file.
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      # The POSTGRES_HOST for your app will now be the Azure DB endpoint.
    volumes:
      # Data volumes are managed by the Azure service, not Docker volumes.
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      # Healthcheck logic remains similar but targets the Azure service hostname.
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} -h ${POSTGRES_HOST}"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ------------------------------------------------------------------------------------
  # ⭐️ RECOMMENDED: Replace with Azure Cache for Redis (Managed Service)
  # ------------------------------------------------------------------------------------
  redis:
    image: redis:alpine # In Azure, you would provision a managed Redis instance.
    container_name: aidocumines-redis
    restart: unless-stopped
    # The REDIS_URL for your app will be the Azure Cache connection string.
    healthcheck:
      test: ["CMD", "redis-cli", "-h", "${REDIS_HOST}", "-p", "${REDIS_PORT}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  # ------------------------------------------------------------------------------------
  # ✅ Your Custom Application Services (Perfect for Containers)
  # These services are stateless and are prime candidates for containerization.
  # ------------------------------------------------------------------------------------

  db_prepare:
    # --- PRODUCTION CHANGE ---
    # The image is pulled from a registry, not built locally.
    # Replace 'your-acr-name.azurecr.io' with your Azure Container Registry name.
    image: your-acr-name.azurecr.io/aidocumines-app:${APP_VERSION:-latest}
    container_name: aidocumines-db-prepare
    # This becomes a one-off "job" or "init container" in Azure.
    restart: on-failure
    command: /app/entrypoint.sh # This entrypoint would run migrations
    environment:
      # All these variables are injected from Azure Key Vault at runtime.
      # --- Secrets ---
      SECRET_KEY: ${SECRET_KEY}
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_HOST: ${POSTGRES_HOST} # <-- Endpoint from Azure managed DB
      POSTGRES_PORT: ${POSTGRES_PORT}
      REDIS_URL: ${REDIS_URL} # <-- Connection string from Azure Cache for Redis
      # --- Config ---
      SERVICE_NAME: db_prepare
      DEBUG: "False"
    depends_on:
      # In Azure, you configure startup order or wait scripts.
      db: { condition: service_healthy }
      redis: { condition: service_healthy }

  web:
    image: your-acr-name.azurecr.io/aidocumines-app:${APP_VERSION:-latest}
    container_name: aidocumines-web
    restart: unless-stopped
    command: /app/entrypoint.sh # This entrypoint would start gunicorn
    environment:
      # Inject all required environment variables, same as db_prepare
      SECRET_KEY: ${SECRET_KEY}
      POSTGRES_DB: ${POSTGRES_DB}
      # ... and so on for all other env vars
      SERVICE_NAME: web
      DEBUG: "False"
      PORT: 8020 # The port your container listens on internally
    ports:
      # In Azure, you map the internal container port (8020) to HTTP/S (80/443)
      # through the App Service or Container App configuration.
      - "80:8020"
    depends_on:
      db_prepare: { condition: service_completed_successfully }

  celery:
    image: your-acr-name.azurecr.io/aidocumines-app:${APP_VERSION:-latest}
    container_name: aidocumines-celery
    restart: unless-stopped
    command: /app/entrypoint.sh # This entrypoint would start a celery worker
    environment:
      # Inject all required environment variables
      SECRET_KEY: ${SECRET_KEY}
      # ... etc.
      SERVICE_NAME: celery
    depends_on:
      db_prepare: { condition: service_completed_successfully }
      redis: { condition: service_healthy }

  celery_beat:
    image: your-acr-name.azurecr.io/aidocumines-app:${APP_VERSION:-latest}
    container_name: aidocumines-celery-beat
    restart: unless-stopped
    command: /app/entrypoint.sh # This entrypoint would start celery beat
    environment:
      # Inject all required environment variables
      SECRET_KEY: ${SECRET_KEY}
      # ... etc.
      SERVICE_NAME: celery_beat
    depends_on:
      db_prepare: { condition: service_completed_successfully }
      redis: { condition: service_healthy }

  # ... The same pattern applies to all your other custom services ...
  # (file_monitor, redis_watchdog, etc.)

  # ------------------------------------------------------------------------------------
  # ⭐️ RECOMMENDED: Replace with Azure AI Search or a dedicated VM
  # ------------------------------------------------------------------------------------
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.0
    # In production, use Azure AI Search for a managed, scalable search experience.

  # ------------------------------------------------------------------------------------
  # ⭐️ RECOMMENDED: Replace with a dedicated VM or Azure Machine Learning
  # ------------------------------------------------------------------------------------
  ollama:
    image: ollama/ollama
    # For production ML models, consider Azure Machine Learning endpoints or a
    # dedicated GPU-enabled Virtual Machine for better performance and management.

  # ------------------------------------------------------------------------------------
  # ⭐️ RECOMMENDED: Replace with Azure Blob Storage
  # ------------------------------------------------------------------------------------
  milvus-minio:
    image: minio/minio:RELEASE.2024-03-30T09-41-56Z
    # MinIO is an S3-compatible object store. The native Azure equivalent is
    # Azure Blob Storage, which is highly scalable, durable, and integrated.

  # Milvus and its dependencies (etcd) are complex. For production, you would typically
  # run this on a dedicated Kubernetes cluster (AKS) for better orchestration.
  milvus:
    image: milvusdb/milvus:v2.4.4
    # ... (dependencies: milvus-etcd, milvus-minio-init)

# In Azure, volumes for persistent data are managed by the respective services.
# For container-specific temporary storage, you can use Azure Files.
volumes:
  postgres_data:
  ollama-data:
  # ... etc.

# In Azure, networking is handled by Virtual Networks (VNet). All services
# deployed within the same VNet can communicate with each other using their
# service names as hostnames.
networks:
  default:
    # No need to define a network here; it's managed by Azure.

