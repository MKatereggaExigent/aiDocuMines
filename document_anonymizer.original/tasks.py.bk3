import os
import json
import logging
import uuid
from celery import shared_task
from django.db import transaction
from django.shortcuts import get_object_or_404
from core.models import File
from document_anonymizer.models import AnonymizationRun, Anonymize, DeAnonymize
from document_anonymizer.utils import AnonymizationService, generate_anonymized_html

logger = logging.getLogger(__name__)


@shared_task
def anonymize_document_task(file_id, file_type="plain"):
    logger.info(f"üîÑ Starting anonymization for file_id={file_id} (type={file_type})")

    file_entry = get_object_or_404(File, id=file_id)
    if not os.path.exists(file_entry.filepath):
        logger.error(f"‚ùå File not found: {file_entry.filepath}")
        return {"error": "File not found", "file_id": file_id}

    anonymized_dir = os.path.join(os.path.dirname(file_entry.filepath), "anonymized")
    os.makedirs(anonymized_dir, exist_ok=True)

    base_filename = f"anonymized_{uuid.uuid4()}"
    txt_path = os.path.join(anonymized_dir, f"{base_filename}.txt")
    json_path = os.path.join(anonymized_dir, f"{base_filename}.json")
    html_path = os.path.join(anonymized_dir, f"{base_filename}.html")
    structured_json_path = os.path.join(anonymized_dir, f"{base_filename}_structured.json")
    structured_txt_path = os.path.join(anonymized_dir, f"{base_filename}_structured.txt")
    structured_html_path = os.path.join(anonymized_dir, f"{base_filename}_structured.html")

    service = AnonymizationService()
    structured_text, elements, elements_json = service.extract_structured_text(file_entry.filepath)

    if not structured_text:
        logger.error(f"‚ùå Failed to extract structured text from {file_entry.filepath}")
        return {"error": "Text extraction failed", "file_id": file_id}

    try:
        updated_blocks = []
        global_combined_map = {}
        global_presidio_map = {}
        global_spacy_map = {}

        for block in elements_json:
            original_text = block.get("text", "")
            masked_text, combined_map, presidio_map, spacy_map = service.anonymize_text(original_text)

            block["text"] = masked_text
            updated_blocks.append(block)
            global_combined_map.update(combined_map)
            global_presidio_map.update(presidio_map)
            global_spacy_map.update(spacy_map)

        final_masked_doc = "\n\n".join(block["text"] for block in updated_blocks)

        with open(txt_path, "w", encoding="utf-8") as f:
            f.write(final_masked_doc)
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(global_combined_map, f, indent=4)
        with open(structured_json_path, "w", encoding="utf-8") as f:
            json.dump(updated_blocks, f, indent=2)
        with open(structured_txt_path, "w", encoding="utf-8") as f:
            f.write(structured_text)

        try:
            html_content = generate_anonymized_html(final_masked_doc, global_combined_map)
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(html_content)
            logger.info(f"‚úÖ HTML file created at {html_path}")
        except Exception as e:
            logger.warning(f"‚ùå HTML generation failed: {e}")
            html_path = None

        try:
            raw_html = generate_anonymized_html(structured_text, {})
            with open(structured_html_path, "w", encoding="utf-8") as f:
                f.write(raw_html)
            logger.info(f"‚úÖ Structured HTML file created at {structured_html_path}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Structured HTML generation failed: {e}")
            structured_html_path = None

        run = AnonymizationRun.objects.create(
            project_id=file_entry.project_id,
            service_id=file_entry.service_id,
            client_name=file_entry.user.username or file_entry.user.email,
            status="Completed",
            anonymization_type="Presidio-Spacy"
        )

        with transaction.atomic():
            Anonymize.objects.filter(original_file=file_entry, file_type=file_type, is_active=True).update(is_active=False)

            Anonymize.objects.create(
                original_file=file_entry,
                run=run,
                file_type=file_type,
                is_active=True,
                anonymized_filepath=txt_path,
                anonymized_html_filepath=html_path,
                entity_mapping_filepath=json_path,
                anonymized_structured_filepath=structured_json_path if file_type == "structured" else None,
                anonymized_structured_txt_filepath=structured_txt_path if file_type == "structured" else None,
                anonymized_structured_html_filepath=structured_html_path if file_type == "structured" else None,
                anonymized_markdown_filepath=None,
                presidio_masking_map=global_presidio_map,
                spacy_masking_map=global_spacy_map,
                status="Completed"
            )

        return {
            "file_id": file_id,
            "anonymization_run_id": str(run.id),
            "file_type": file_type,
            "anonymized_txt": txt_path,
            "anonymized_json": json_path,
            "anonymized_html": html_path,
            "structured_blocks": structured_json_path if file_type == "structured" else None,
            "structured_txt": structured_txt_path if file_type == "structured" else None,
            "structured_html": structured_html_path if file_type == "structured" else None,
            "status": "Completed"
        }

    except Exception as e:
        logger.exception(f"‚ùå Anonymization task failed for file_id={file_id}: {e}")
        return {"error": str(e), "file_id": file_id}


@shared_task
def deanonymize_document_task(file_id):
    logger.info(f"üîÑ Starting de-anonymization for file_id={file_id}")

    instance = get_object_or_404(Anonymize, original_file_id=file_id, is_active=True, file_type="plain")

    if not os.path.exists(instance.anonymized_filepath):
        return {"error": "Missing anonymized file", "file_id": file_id}

    with open(instance.anonymized_filepath, "r", encoding="utf-8") as f:
        masked_text = f.read()

    service = AnonymizationService()
    final_text = service.deanonymize_pipeline(
        masked_text,
        spacy_mapping=instance.spacy_masking_map or {},
        presidio_mapping=instance.presidio_masking_map or {}
    )

    deanonymized_dir = os.path.join(os.path.dirname(instance.original_file.filepath), "deanonymized")
    os.makedirs(deanonymized_dir, exist_ok=True)
    txt_path = os.path.join(deanonymized_dir, f"deanonymized_{uuid.uuid4()}.txt")

    with open(txt_path, "w", encoding="utf-8") as f:
        f.write(final_text)

    with transaction.atomic():
        DeAnonymize.objects.create(
            file=instance.original_file,
            unmasked_text=final_text,
            unmasked_filepath=txt_path,
            status="Completed"
        )

    logger.info(f"‚úÖ De-anonymization complete for file_id={file_id}")
    return {"file_id": file_id, "deanonymized_txt": txt_path, "status": "Completed"}

