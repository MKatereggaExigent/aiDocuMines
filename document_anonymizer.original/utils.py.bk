import os
import json
import re
import fitz  # PyMuPDF for text extraction
import spacy
import logging
from presidio_analyzer import AnalyzerEngine
from presidio_anonymizer import AnonymizerEngine
from django.conf import settings
from docx import Document

logger = logging.getLogger(__name__)

class AnonymizationService:
    """
    Handles document text extraction, anonymization, and de-anonymization.
    """

    def extract_text_from_file(self, file_path):
        """
        Extracts text from a file (PDF, TXT, DOCX).
        """
        logger.info(f"üîÑ Extracting text from: {file_path}")

        if not os.path.exists(file_path):
            logger.error(f"‚ùå File not found: {file_path}")
            return None

        try:
            if file_path.lower().endswith(".pdf"):
                return self.extract_text_from_pdf(file_path)
            elif file_path.lower().endswith(".txt"):
                with open(file_path, "r", encoding="utf-8") as f:
                    return f.read().strip()
            elif file_path.lower().endswith(".docx"):
                return self.extract_text_from_docx(file_path)
            else:
                logger.warning(f"‚ö†Ô∏è Unsupported file type: {file_path}")
                return None
        except Exception as e:
            logger.error(f"‚ùå Failed to extract text from {file_path}: {e}")
            return None

    def extract_text_from_pdf(self, file_path):
        """
        Extracts text from a PDF document using PyMuPDF.
        """
        try:
            pdf_document = fitz.open(file_path)
            text = "\n".join([page.get_text("text") for page in pdf_document])
            pdf_document.close()
            return text.strip()
        except Exception as e:
            logger.error(f"‚ùå PDF text extraction failed: {e}")
            return None

    def extract_text_from_docx(self, file_path):
        """
        Extracts text from a DOCX file.
        """
        try:
            doc = Document(file_path)
            return "\n".join([para.text for para in doc.paragraphs]).strip()
        except Exception as e:
            logger.error(f"‚ùå DOCX text extraction failed: {e}")
            return None

    def anonymize_text(self, text, anonymization_type="Presidio"):
        """
        Anonymizes text using Presidio and spaCy.
        Returns:
        - Masked text
        - Entity masking maps for both Presidio and spaCy
        """

        analyzer = AnalyzerEngine()
        anonymizer = AnonymizerEngine()

        logger.info(f"üîÑ Running {anonymization_type} anonymization...")

        entity_mapping_presidio = {}
        entity_mapping_spacy = {}
        entity_counter = {}
        masked_text = text

        if anonymization_type == "Presidio":
            results = analyzer.analyze(text=text, entities=[], language="en")

            for result in results:
                entity_type = result.entity_type
                entity_counter[entity_type] = entity_counter.get(entity_type, 0) + 1
                mask = f"{entity_type}_MASKED_{entity_counter[entity_type]}"
                entity_mapping_presidio[mask] = text[result.start:result.end].strip()
                masked_text = re.sub(r'\b' + re.escape(text[result.start:result.end]) + r'\b', mask, masked_text, 1)

        elif anonymization_type == "Spacy":
            nlp = spacy.load("en_core_web_lg")
            doc = nlp(text)

            for ent in doc.ents:
                entity_type = ent.label_
                entity_counter[entity_type] = entity_counter.get(entity_type, 0) + 1
                mask = f"{entity_type}_MASKED_{entity_counter[entity_type]}"
                entity_mapping_spacy[mask] = ent.text.strip()
                masked_text = re.sub(r'\b' + re.escape(ent.text) + r'\b', mask, masked_text, 1)

        logger.info(f"‚úÖ Entity Masking Map for Presidio: {json.dumps(entity_mapping_presidio, indent=4)}")
        logger.info(f"‚úÖ Entity Masking Map for Spacy: {json.dumps(entity_mapping_spacy, indent=4)}")

        return masked_text, entity_mapping_presidio, entity_mapping_spacy

    def reverse_masking(self, text, entity_mapping):
        """
        Reverses anonymization using the given entity mapping.
        """
        for mask, original in sorted(entity_mapping.items(), key=lambda x: len(x[0]), reverse=True):
            pattern = re.compile(r'\b' + re.escape(mask) + r'\b')
            text = pattern.sub(original, text)
        return text

    def get_file_path(self, original_file_path, folder="anonymized", extension="txt"):
        """
        Generates a structured file path for anonymized/de-anonymized files.
        """
        directory = os.path.join(os.path.dirname(original_file_path), folder)
        os.makedirs(directory, exist_ok=True)
        filename = os.path.basename(original_file_path).replace(".pdf", f".{extension}")
        return os.path.join(directory, filename)


def generate_anonymized_html(masked_text, entity_mapping):
    """
    Generates an HTML representation of the anonymized text with highlights.
    """
    html_template = """<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Anonymized Document</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }}
            .masked {{ background-color: yellow; font-weight: bold; padding: 2px; }}
            pre {{ white-space: pre-wrap; word-wrap: break-word; }}
        </style>
    </head>
    <body>
        <h2>Anonymized Document</h2>
        <pre>{text}</pre>
        <h3>Entity Mapping</h3>
        <pre>{entity_map}</pre>
    </body>
    </html>
    """

    # ‚úÖ Highlight anonymized entities in the HTML output
    highlighted_text = masked_text
    for mask, original in entity_mapping.items():
        highlighted_text = highlighted_text.replace(mask, f'<span class="masked">{mask}</span>')

    # ‚úÖ Properly format JSON data for the entity mapping section
    entity_map_json = json.dumps(entity_mapping, indent=4)

    return html_template.replace("{text}", highlighted_text).replace("{entity_map}", entity_map_json)
