from django.db import models
from core.models import File  # ✅ Reference to the original File model from core
import uuid


class AnonymizationRun(models.Model):
    """
    Tracks each anonymization request.
    """
    STATUS_CHOICES = [
        ('Pending', 'Pending'),
        ('Processing', 'Processing'),
        ('Completed', 'Completed'),
        ('Failed', 'Failed')
    ]

    ANONYMIZATION_TYPE_CHOICES = [
        ('Presidio', 'Presidio-based Anonymization'),
        ('Spacy', 'Spacy-based Anonymization')
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    project_id = models.CharField(max_length=255, db_index=True)
    service_id = models.CharField(max_length=255, db_index=True)
    client_name = models.CharField(max_length=255, db_index=True)  # ✅ Include client_name for tracking
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='Pending', db_index=True)
    anonymization_type = models.CharField(max_length=20, choices=ANONYMIZATION_TYPE_CHOICES, default='Presidio', db_index=True)  # ✅ Store anonymization type
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    error_message = models.TextField(blank=True, null=True)  # ✅ Store errors if anonymization fails

    def __str__(self):
        return f"AnonymizationRun {self.id} - {self.status} ({self.anonymization_type})"


class Anonymize(models.Model):
    """
    Stores details of both the original and anonymized files.
    - Links to `File` from `core.models` (original file)
    - Stores the anonymized file paths
    """
    STATUS_CHOICES = [
        ('Processing', 'Processing'),
        ('Completed', 'Completed'),
        ('Failed', 'Failed')
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)  # ✅ Ensure unique file ID
    run = models.ForeignKey(
        AnonymizationRun, on_delete=models.CASCADE, related_name="anonymized_files", null=True, blank=True
    )  # ✅ Ensures proper cleanup on run deletion
    original_file = models.ForeignKey(File, on_delete=models.CASCADE, related_name="anonymized_versions")  # ✅ Link to the original file
    anonymized_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Path to anonymized PDF
    anonymized_txt_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Path to anonymized text file
    anonymized_html_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Path to anonymized HTML file
    entity_mapping_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Store JSON file path (NEW FIELD)
    presidio_masking_map = models.JSONField(blank=True, null=True)  # ✅ Mapping of masked entities in Presidio
    spacy_masking_map = models.JSONField(blank=True, null=True)  # ✅ Mapping of masked entities in Spacy
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='Processing', db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Anonymized File {self.original_file.filename} - {self.status}"


class DeAnonymize(models.Model):
    """
    Stores details of de-anonymized documents.
    - Links back to the original file
    - Stores mapping for de-anonymization
    """
    STATUS_CHOICES = [
        ('Processing', 'Processing'),
        ('Completed', 'Completed'),
        ('Failed', 'Failed')
    ]

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    run = models.ForeignKey(
        AnonymizationRun, on_delete=models.CASCADE, related_name="deanonymized_files", null=True, blank=True
    )  # ✅ Ensures proper cleanup on run deletion
    file = models.ForeignKey(File, on_delete=models.CASCADE, related_name="deanonymized_versions")  # ✅ Link to the original file
    unmasked_text = models.TextField(blank=True, null=True)  # ✅ Stores recovered original text
    masked_text = models.TextField(blank=True, null=True)  # ✅ Stores masked text before de-anonymization
    presidio_masking_map = models.JSONField(blank=True, null=True)  # ✅ Mapping of masked entities in Presidio
    spacy_masking_map = models.JSONField(blank=True, null=True)  # ✅ Mapping of masked entities in Spacy
    unmasked_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Path to de-anonymized text file
    deanonymized_pdf_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Path to de-anonymized PDF
    deanonymized_html_filepath = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Path to de-anonymized HTML
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='Processing', db_index=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"DeAnonymized File {self.file.filename} - {self.status}"


class AnonymizationStorage(models.Model):
    """
    Represents storage locations for uploaded, anonymized, and de-anonymized files.
    """
    storage_id = models.AutoField(primary_key=True)
    run = models.ForeignKey(
        AnonymizationRun, on_delete=models.CASCADE, related_name="storages", null=True, blank=True
    )  # ✅ Ensures proper cleanup on run deletion
    upload_storage_location = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Original file path
    anonymized_storage_location = models.CharField(max_length=1024, blank=True, null=True)  # ✅ Anonymized file path
    deanonymized_storage_location = models.CharField(max_length=1024, blank=True, null=True)  # ✅ De-anonymized file path
    
    def __str__(self):
        return f"Storage {self.storage_id} - {self.upload_storage_location}"
