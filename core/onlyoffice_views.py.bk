# core/onlyoffice_views.py
import os
import time
import uuid
import jwt
import logging
import requests
import mimetypes

from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import get_object_or_404
from django.conf import settings
from django.contrib.contenttypes.models import ContentType

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny

from oauth2_provider.contrib.rest_framework import OAuth2Authentication, TokenHasReadWriteScope
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

from core.models import File, Storage, Run
from core.onlyoffice_utils import (
    make_signed_download_url,
    verify_signed_download_token,
    ext_from_filename,
    mime_for_ext,
    ensure_unique_path,
    file_md5,
    parse_ds_response,
    redact_url,
)

logger = logging.getLogger(__name__)

# ─────────────────────────────────────────────────────────────────────────────
# Swagger params
file_id_param = openapi.Parameter(
    "file_id", openapi.IN_QUERY, type=openapi.TYPE_INTEGER, required=True, description="Source file ID"
)
output_type_param = openapi.Parameter(
    "output_type", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=False, description="Target type (e.g., pdf, xlsx)"
)


class OnlyOfficeConvertView(APIView):
    """
    Convert a stored file via OnlyOffice Document Server.

    Strategy (based on DS behavior you confirmed):
      1) Try /converter with BODY token (claims WITHOUT 'payload' wrapper).
      2) If DS returns -8, try /ConvertService.ashx with HEADER token
         (claims WITH 'payload' wrapper in the JWT).
      3) Try both internal Docker DNS base (http://onlyoffice) and the external URL from settings.
    """
    authentication_classes = [OAuth2Authentication]
    permission_classes = [TokenHasReadWriteScope]

    @swagger_auto_schema(
        operation_description="Convert a file to another format. Returns a new stored File record.",
        tags=["OnlyOffice"],
        manual_parameters=[file_id_param, output_type_param],
        responses={200: "Success", 400: "Bad Request", 404: "Not Found"},
    )
    def post(self, request):
        file_id = request.query_params.get("file_id")
        output_type = (request.query_params.get("output_type") or "pdf").lower()

        if not file_id:
            return Response({"error": "Missing file_id"}, status=400)

        src = get_object_or_404(File, id=file_id)

        # Build signed URL for DS to pull from our API
        # NOTE: correct argument order: (file_id, request=...)
        source_url = make_signed_download_url(str(src.id), request=request)
        safe_source_url = redact_url(source_url)

        input_ext = ext_from_filename(src.filename, fallback="docx")

        # Prefer internal Docker DNS, then fall back to external URL
        ds_external = settings.ONLYOFFICE["DOC_SERVER_URL"].rstrip("/")
        ds_bases = []
        # Internal container-to-container path (plain HTTP) if resolvable by Docker DNS
        ds_bases.append("http://onlyoffice")
        if ds_external not in ds_bases:
            ds_bases.append(ds_external)

        secret = settings.ONLYOFFICE["JWT_SECRET"]
        conv_key = str(uuid.uuid4())
        now = int(time.time())
        exp = now + 300

        # BODY claims (no 'payload' wrapper) — used with POST /converter { "token": "<jwt>" }
        body_claims = {
            "filetype":  input_ext,
            "key":       conv_key,
            "outputtype": output_type,
            "title":     src.filename,
            "url":       source_url,
            "iat":       now,
            "exp":       exp,
        }

        # HEADER claims (with 'payload' wrapper) — used with Authorization: Bearer <jwt> to .ashx
        header_claims = {
            "payload": {
                "filetype":  input_ext,
                "key":       conv_key,
                "outputtype": output_type,
                "title":     src.filename,
                "url":       source_url,
            },
            "iat": now,
            "exp": exp,
        }

        def call_converter_with_body_token(base_url: str):
            token = jwt.encode(body_claims, secret, algorithm="HS256")
            body = {
                # DS ignores these when "token" is present, but including them is harmless
                "async": False,
                "filetype": input_ext,
                "outputtype": output_type,
                "key": conv_key,
                "title": src.filename,
                "url": source_url,
                "token": token,
            }
            return requests.post(base_url.rstrip("/") + "/converter", json=body, timeout=180)

        def call_ashx_with_header_token(base_url: str):
            token = jwt.encode(header_claims, secret, algorithm="HS256")
            headers = {"Authorization": f"Bearer {token}"}
            body = {
                "async": False,
                "filetype": input_ext,
                "outputtype": output_type,
                "key": conv_key,
                "title": src.filename,
                "url": source_url,
            }
            return requests.post(base_url.rstrip("/") + "/ConvertService.ashx", json=body, headers=headers, timeout=180)

        last_err_payload = None

        for base in ds_bases:
            # 1) Try /converter + BODY token
            try:
                r1 = call_converter_with_body_token(base)
            except requests.RequestException as e:
                logger.warning("OnlyOffice unreachable at %s/converter: %s", base, e)
                last_err_payload = {
                    "error": "unreachable",
                    "message": f"OnlyOffice unreachable at {base}/converter",
                    "exception": str(e),
                    "ds_base": base,
                }
                continue

            ok1, d1 = parse_ds_response(r1)
            if ok1:
                data = d1
                break

            # If token rejected, retry header path on the same base
            if isinstance(d1, dict) and d1.get("error") == -8:
                try:
                    r2 = call_ashx_with_header_token(base)
                except requests.RequestException as e:
                    logger.warning("OnlyOffice unreachable at %s/ConvertService.ashx: %s", base, e)
                    last_err_payload = {
                        "error": "unreachable",
                        "message": f"OnlyOffice unreachable at {base}/ConvertService.ashx",
                        "exception": str(e),
                        "ds_base": base,
                    }
                    continue

                ok2, d2 = parse_ds_response(r2)
                if ok2:
                    data = d2
                    break

                # still not OK on header path — remember diagnostics and try next base
                last_err_payload = {
                    "error": d2.get("error", -1),
                    "message": "Invalid token from Document Server (header path).",
                    "ds_base": base,
                    "we_signed_fields": {
                        "filetype": input_ext,
                        "key": conv_key,
                        "outputtype": output_type,
                        "title": src.filename,
                        "url": safe_source_url,
                    },
                    "raw": d2,
                }
                continue

            # Other DS error (e.g. cannot download source). Try next base.
            last_err_payload = {
                "error": d1.get("error", -1),
                "message": "Document Server returned an error (body path).",
                "ds_base": base,
                "raw": d1,
            }
            continue
        else:
            # Exhausted all bases without success
            if not last_err_payload:
                last_err_payload = {"error": -1, "message": "Unknown OnlyOffice error"}
            # Help the operator with actionable hints
            last_err_payload["hints"] = {
                "compare_secret": "settings.ONLYOFFICE['JWT_SECRET'] must equal DS services.CoAuthoring.secret.*",
                "note": "Tried http://onlyoffice and your DOC_SERVER_URL; verify that at least one works from the API container.",
            }
            return Response(last_err_payload, status=502)

        # Respect async/progress even with async=False (DS sometimes returns percent)
        if not data.get("endConvert") and "percent" in data:
            return Response({"error": "Conversion in progress", "percent": data.get("percent")}, status=202)

        result_url = data.get("fileUrl")
        if not result_url:
            return Response({"error": "OnlyOffice did not return fileUrl", "raw": data}, status=502)

        # Download the converted file
        try:
            rr = requests.get(result_url, stream=True, timeout=180)
            rr.raise_for_status()
        except requests.RequestException as e:
            logger.exception("Failed to fetch converted file")
            return Response({"error": f"Failed to fetch converted file: {e}"}, status=502)

        # Persist beside original (map /app/ -> host path like your download view does)
        base_dir = os.path.dirname(src.filepath.replace("/app/", "")) or settings.MEDIA_ROOT
        name_no_ext, _ = os.path.splitext(src.filename)
        out_filename = f"{name_no_ext}.{output_type}"
        out_path = ensure_unique_path(base_dir, out_filename)

        with open(out_path, "wb") as fp:
            for chunk in rr.iter_content(chunk_size=1024 * 1024):
                if chunk:
                    fp.write(chunk)

        # Create Storage + File rows
        storage = Storage.objects.create(
            user=src.user,
            content_type=ContentType.objects.get_for_model(Run),
            upload_storage_location=out_path,
        )
        mime = mime_for_ext(output_type)
        new_file = File.objects.create(
            run=src.run,
            storage=storage,
            filename=os.path.basename(out_path),
            filepath=out_path,
            file_size=os.path.getsize(out_path),
            file_type=mime,
            md5_hash=file_md5(out_path),
            user=src.user,
            project_id=src.project_id,
            service_id=src.service_id,
            extension=output_type,
        )

        return Response(
            {
                "message": "Converted successfully",
                "source_file_id": src.id,
                "converted_file_id": new_file.id,
                "filename": new_file.filename,
                "mime_type": new_file.file_type,
                "size": new_file.file_size,
            },
            status=200,
        )


# Keep this so core/urls.py import works even if you’re not using it right now.
class OnlyOfficeCommandView(APIView):
    authentication_classes = [OAuth2Authentication]
    permission_classes = [TokenHasReadWriteScope]

    @swagger_auto_schema(
        operation_description="Relay a coauthoring command to OnlyOffice (forcesave, etc.)",
        tags=["OnlyOffice"],
        request_body=openapi.Schema(type=openapi.TYPE_OBJECT),
        responses={200: "Success", 400: "Bad Request"},
    )
    def post(self, request):
        url = settings.ONLYOFFICE["DOC_SERVER_URL"].rstrip("/") + "/coauthoring/CommandService.ashx"
        try:
            r = requests.post(url, json=request.data, timeout=30)
            ct = (r.headers.get("Content-Type") or "").lower()
            if "application/json" in ct:
                return Response(r.json(), status=r.status_code)
            return Response({"body": r.text[:1000]}, status=r.status_code)
        except requests.RequestException as e:
            return Response({"error": f"OnlyOffice unreachable: {e}"}, status=502)


@method_decorator(csrf_exempt, name="dispatch")
class OnlyOfficeSignedDownloadView(APIView):
    """
    AllowAny: Called by OnlyOffice Document Server to pull the source file using a signed token.
    """
    permission_classes = [AllowAny]

    @swagger_auto_schema(
        operation_description="Internal: OnlyOffice fetches file via signed token.",
        tags=["OnlyOffice (internal)"],
        manual_parameters=[
            openapi.Parameter("file_id", openapi.IN_QUERY, type=openapi.TYPE_INTEGER, required=True),
            openapi.Parameter("token", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=True),
        ],
        responses={200: "Success", 403: "Forbidden", 404: "Not Found"},
    )
    def get(self, request):
        file_id = request.query_params.get("file_id")
        token = request.query_params.get("token")
        if not (file_id and token):
            return Response({"error": "Missing file_id or token"}, status=400)

        if not verify_signed_download_token(token, str(file_id)):
            return Response({"error": "Invalid or expired token"}, status=403)

        f = get_object_or_404(File, id=file_id)

        # Map container path to host, like your FileDownloadView does
        real_path = f.filepath.replace("/app/", "")
        if not os.path.exists(real_path):
            return Response({"error": "File not found"}, status=404)

        from django.http import FileResponse
        content_type, _ = mimetypes.guess_type(real_path)
        if not content_type:
            content_type = "application/octet-stream"
        return FileResponse(
            open(real_path, "rb"),
            as_attachment=False,
            filename=os.path.basename(real_path),
            content_type=content_type,
        )


@method_decorator(csrf_exempt, name="dispatch")
class OnlyOfficeCallbackView(APIView):
    """
    Optional: receive callbacks from the editors (if you embed them).
    """
    permission_classes = [AllowAny]

    @swagger_auto_schema(
        operation_description="Callback endpoint for OnlyOffice editors.",
        tags=["OnlyOffice"],
        request_body=openapi.Schema(type=openapi.TYPE_OBJECT),
        responses={200: "OK"},
    )
    def post(self, request):
        return Response({"ok": True})

