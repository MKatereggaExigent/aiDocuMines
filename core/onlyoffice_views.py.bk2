# core/onlyoffice_views.py
import os
import hashlib
import time
import uuid
import jwt
import logging
import requests
import mimetypes

from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.shortcuts import get_object_or_404
from django.conf import settings
from django.contrib.contenttypes.models import ContentType

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny

from oauth2_provider.contrib.rest_framework import OAuth2Authentication, TokenHasReadWriteScope
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi


from docx import Document as DocxDocument
from core.onlyoffice_utils import file_md5

from django.db import transaction

# --- add near the other imports ---
from django.contrib.auth import get_user_model
User = get_user_model()

# ... keep existing views ...
from core.models import File, Storage, Run
from core.onlyoffice_utils import (
    make_signed_download_url,
    verify_signed_download_token,
    ext_from_filename,
    mime_for_ext,
    ensure_unique_path,
    file_md5,
    parse_ds_response,
    redact_url,  # make sure this exists; if not, just mask token manually before logging
)

logger = logging.getLogger(__name__)

file_id_param = openapi.Parameter(
    "file_id", openapi.IN_QUERY, type=openapi.TYPE_INTEGER, required=True, description="Source file ID"
)
output_type_param = openapi.Parameter(
    "output_type", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=False, description="Target type (e.g., pdf, xlsx)"
)

class OnlyOfficeConvertView(APIView):
    """
    Convert a stored file via OnlyOffice Document Server.

    Strategy:
      1) Try /converter with BODY token (no 'payload' wrapper) on http://onlyoffice
      2) If -8, try /ConvertService.ashx with HEADER token ('payload' wrapper)
      3) If still failing, try external DS URL from settings
      4) All DS requests bypass env proxies (trust_env=False) to avoid being routed to our own app
    """
    authentication_classes = [OAuth2Authentication]
    permission_classes = [TokenHasReadWriteScope]

    @swagger_auto_schema(
        operation_description="Convert a file to another format. Returns a new stored File record.",
        tags=["OnlyOffice"],
        manual_parameters=[file_id_param, output_type_param],
        responses={200: "Success", 400: "Bad Request", 404: "Not Found"},
    )
    def post(self, request):
        file_id = request.query_params.get("file_id")
        output_type = (request.query_params.get("output_type") or "pdf").lower()

        if not file_id:
            return Response({"error": "Missing file_id"}, status=400)

        src = get_object_or_404(File, id=file_id)

        # Signed URL for DS to pull from our API (external host)
        source_url = make_signed_download_url(str(src.id), request=request)
        try:
            safe_source_url = redact_url(source_url)
        except Exception:
            # Fallback redaction if helper is missing
            safe_source_url = source_url.split("token=")[0] + "token=***redacted***"

        input_ext = ext_from_filename(src.filename, fallback="docx")
        
        # ds_external = settings.ONLYOFFICE["DOC_SERVER_URL"].rstrip("/")

        # Order matters: prefer internal Docker DNS first (fast, no TLS), then external URL
        # ds_bases = []
        # if "onlyoffice" not in ds_bases:
        #     ds_bases.append("http://onlyoffice")
        # if ds_external and ds_external not in ds_bases:
        #     ds_bases.append(ds_external)

        ds_internal = settings.ONLYOFFICE["DOC_SERVER_URL"].rstrip("/")
        ds_public  = settings.ONLYOFFICE.get("DOC_SERVER_PUBLIC_URL", ds_internal).rstrip("/")

        # Prefer docker DNS, then configured internal, then public TLS URL
        ds_bases = []
        for base in ("http://onlyoffice", ds_internal, ds_public):
            if base and base not in ds_bases:
                ds_bases.append(base)

        secret = settings.ONLYOFFICE["JWT_SECRET"]
        conv_key = str(uuid.uuid4())
        now = int(time.time())
        exp = now + 300

        body_claims = {
            "filetype":  input_ext,
            "key":       conv_key,
            "outputtype": output_type,
            "title":     src.filename,
            "url":       source_url,
            "iat":       now,
            "exp":       exp,
        }
        header_claims = {
            "payload": {
                "filetype":  input_ext,
                "key":       conv_key,
                "outputtype": output_type,
                "title":     src.filename,
                "url":       source_url,
            },
            "iat": now,
            "exp": exp,
        }

        # ---- BYPASS PROXIES ----
        sess = requests.Session()
        sess.trust_env = False  # ignore HTTP(S)_PROXY, NO_PROXY, etc. for DS calls

        # conservative connect/read timeouts
        T_CONN, T_READ = 5, 45

        def call_converter_with_body_token(base_url: str):
            token = jwt.encode(body_claims, secret, algorithm="HS256")
            body = {
                "async": False,
                "filetype": input_ext,
                "outputtype": output_type,
                "key": conv_key,
                "title": src.filename,
                "url": source_url,
                "token": token,
            }
            url = base_url.rstrip("/") + "/converter"
            logger.info("OnlyOffice convert (body token) POST %s", url)
            return sess.post(url, json=body, timeout=(T_CONN, T_READ))

        def call_ashx_with_header_token(base_url: str):
            token = jwt.encode(header_claims, secret, algorithm="HS256")
            headers = {"Authorization": f"Bearer {token}"}
            body = {
                "async": False,
                "filetype": input_ext,
                "outputtype": output_type,
                "key": conv_key,
                "title": src.filename,
                "url": source_url,
            }
            url = base_url.rstrip("/") + "/ConvertService.ashx"
            logger.info("OnlyOffice convert (header token) POST %s", url)
            return sess.post(url, json=body, headers=headers, timeout=(T_CONN, T_READ))

        last_err_payload = None
        data = None

        for base in ds_bases:
            # 1) /converter (body token)
            try:
                r1 = call_converter_with_body_token(base)
            except requests.RequestException as e:
                logger.warning("OnlyOffice unreachable at %s/converter: %s", base, e)
                last_err_payload = {
                    "error": "unreachable",
                    "message": f"OnlyOffice unreachable at {base}/converter",
                    "exception": str(e),
                    "ds_base": base,
                }
                continue

            ok1, d1 = parse_ds_response(r1)
            if ok1:
                data = d1
                break

            if isinstance(d1, dict) and d1.get("error") == -8:
                # 2) /ConvertService.ashx (header token)
                try:
                    r2 = call_ashx_with_header_token(base)
                except requests.RequestException as e:
                    logger.warning("OnlyOffice unreachable at %s/ConvertService.ashx: %s", base, e)
                    last_err_payload = {
                        "error": "unreachable",
                        "message": f"OnlyOffice unreachable at {base}/ConvertService.ashx",
                        "exception": str(e),
                        "ds_base": base,
                    }
                    continue

                ok2, d2 = parse_ds_response(r2)
                if ok2:
                    data = d2
                    break

                last_err_payload = {
                    "error": d2.get("error", -1),
                    "message": "Invalid token from Document Server (header path).",
                    "ds_base": base,
                    "we_signed_fields": {
                        "filetype": input_ext,
                        "key": conv_key,
                        "outputtype": output_type,
                        "title": src.filename,
                        "url": safe_source_url,
                    },
                    "raw": d2,
                }
                continue

            last_err_payload = {
                "error": d1.get("error", -1),
                "message": "Document Server returned an error (body path).",
                "ds_base": base,
                "raw": d1,
            }
            continue

        if data is None:
            if not last_err_payload:
                last_err_payload = {"error": -1, "message": "Unknown OnlyOffice error"}
            last_err_payload["hints"] = {
                "compare_secret": "settings.ONLYOFFICE['JWT_SECRET'] must equal DS services.CoAuthoring.secret.*",
                "note": "Tried http://onlyoffice and DOC_SERVER_URL; also bypassed proxies via trust_env=False.",
            }
            return Response(last_err_payload, status=502)

        # Progress?
        if not data.get("endConvert") and "percent" in data:
            return Response({"error": "Conversion in progress", "percent": data.get("percent")}, status=202)

        result_url = data.get("fileUrl")
        if not result_url:
            return Response({"error": "OnlyOffice did not return fileUrl", "raw": data}, status=502)

        # Download converted file (also bypass proxies)
        try:
            rr = sess.get(result_url, stream=True, timeout=(T_CONN, 120))
            rr.raise_for_status()
        except requests.RequestException as e:
            logger.exception("Failed to fetch converted file from DS cache: %s", e)
            return Response({"error": f"Failed to fetch converted file: {e}"}, status=502)

        # Save alongside the source file (match your folder tree)
        base_dir = os.path.dirname(src.filepath)  # keep /app/... in-container path
        name_no_ext, _ = os.path.splitext(src.filename)
        out_filename = f"{name_no_ext}.{output_type}"
        out_path = ensure_unique_path(base_dir, out_filename)

        with open(out_path, "wb") as fp:
            for chunk in rr.iter_content(chunk_size=1024 * 1024):
                if chunk:
                    fp.write(chunk)

        storage = Storage.objects.create(
            user=src.user,
            content_type=ContentType.objects.get_for_model(Run),
            upload_storage_location=out_path,
        )
        mime = mime_for_ext(output_type)
        new_file = File.objects.create(
            run=src.run,
            storage=storage,
            filename=os.path.basename(out_path),
            filepath=out_path,
            file_size=os.path.getsize(out_path),
            file_type=mime,
            md5_hash=file_md5(out_path),
            user=src.user,
            project_id=src.project_id,
            service_id=src.service_id,
            extension=output_type,
        )

        return Response(
            {
                "message": "Converted successfully",
                "source_file_id": src.id,
                "converted_file_id": new_file.id,
                "filename": new_file.filename,
                "mime_type": new_file.file_type,
                "size": new_file.file_size,
            },
            status=200,
        )


class OnlyOfficeCommandView(APIView):
    authentication_classes = [OAuth2Authentication]
    permission_classes = [TokenHasReadWriteScope]

    @swagger_auto_schema(
        operation_description="Relay a coauthoring command to OnlyOffice (forcesave, etc.)",
        tags=["OnlyOffice"],
        request_body=openapi.Schema(type=openapi.TYPE_OBJECT),
        responses={200: "Success", 400: "Bad Request"},
    )
    def post(self, request):
        url = settings.ONLYOFFICE["DOC_SERVER_URL"].rstrip("/") + "/coauthoring/CommandService.ashx"
        try:
            r = requests.post(url, json=request.data, timeout=30)
            ct = (r.headers.get("Content-Type") or "").lower()
            if "application/json" in ct:
                return Response(r.json(), status=r.status_code)
            return Response({"body": r.text[:1000]}, status=r.status_code)
        except requests.RequestException as e:
            return Response({"error": f"OnlyOffice unreachable: {e}"}, status=502)


@method_decorator(csrf_exempt, name="dispatch")
class OnlyOfficeSignedDownloadView(APIView):
    permission_classes = [AllowAny]

    @swagger_auto_schema(
        operation_description="Internal: OnlyOffice fetches file via signed token.",
        tags=["OnlyOffice (internal)"],
        manual_parameters=[
            openapi.Parameter("file_id", openapi.IN_QUERY, type=openapi.TYPE_INTEGER, required=True),
            openapi.Parameter("token", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=True),
        ],
        responses={200: "Success", 403: "Forbidden", 404: "Not Found"},
    )
    def get(self, request):
        file_id = request.query_params.get("file_id")
        token = request.query_params.get("token")
        if not (file_id and token):
            return Response({"error": "Missing file_id or token"}, status=400)

        if not verify_signed_download_token(token, str(file_id)):
            return Response({"error": "Invalid or expired token"}, status=403)

        f = get_object_or_404(File, id=file_id)

        # Prefer in-container path; fall back to stripped host-like path if needed
        real_path = f.filepath
        if not os.path.exists(real_path):
            alt = real_path.replace("/app/", "")
            if os.path.exists(alt):
                real_path = alt
            else:
                return Response({"error": "File not found"}, status=404)

        from django.http import FileResponse
        content_type, _ = mimetypes.guess_type(real_path)
        if not content_type:
            content_type = "application/octet-stream"
        return FileResponse(
            open(real_path, "rb"),
            as_attachment=False,
            filename=os.path.basename(real_path),
            content_type=content_type,
        )


@method_decorator(csrf_exempt, name="dispatch")
class OnlyOfficeCallbackView(APIView):
    permission_classes = [AllowAny]

    @swagger_auto_schema(
        operation_description="Callback endpoint for OnlyOffice editors.",
        tags=["OnlyOffice"],
        request_body=openapi.Schema(type=openapi.TYPE_OBJECT),
        responses={200: "OK"},
    )
    def post(self, request):
        return Response({"ok": True})


class OnlyOfficeEditorConfigView(APIView):
    """
    Returns the config object and the public DocServer JS URL so the frontend
    can do: new DocsAPI.DocEditor('container', config).
    """
    authentication_classes = [OAuth2Authentication]
    permission_classes = [TokenHasReadWriteScope]

    @swagger_auto_schema(
        operation_description="Get OnlyOffice editor config for a file.",
        tags=["OnlyOffice"],
        manual_parameters=[
            openapi.Parameter("file_id", openapi.IN_QUERY, type=openapi.TYPE_INTEGER, required=True),
        ],
        responses={200: "Success", 400: "Bad Request", 404: "Not Found"},
    )
    def get(self, request):
        file_id = request.query_params.get("file_id")
        if not file_id:
            return Response({"error": "Missing file_id"}, status=400)

        f = get_object_or_404(File, id=file_id)

        # File URL OnlyOffice server will fetch (server-to-server)
        download_url = make_signed_download_url(str(f.id), request=request)

        # Decide the public DS URL for the browser to load api.js from
        # ds_public = (
        #     getattr(settings, "ONLYOFFICE", {}).get("PUBLIC_URL")
        #     or settings.ONLYOFFICE["DOC_SERVER_URL"]
        # ).rstrip("/")


        ds_public = (
            settings.ONLYOFFICE.get("DOC_SERVER_PUBLIC_URL")
            or settings.ONLYOFFICE["DOC_SERVER_URL"]
        ).rstrip("/")

        doc_api_js = ds_public + "/web-apps/apps/api/documents/api.js"

        ext = ext_from_filename(f.filename, fallback="docx")
        document_type = "word"  # you can map by ext if you like

        # You can inject the current user; fall back to file owner
        u = getattr(request, "user", None) or f.user
        user_id = str(getattr(u, "id", "user"))
        user_name = getattr(u, "username", None) or getattr(u, "email", None) or "User"

        # Callback is optional (used if you embed real-time editors and want save events)
        callback_url = settings.API_BASE_URL.rstrip("/") + f"/api/v1/core/onlyoffice/callback/?file_id={f.id}"

        cfg = {
            "documentType": document_type,
            "document": {
                "fileType": ext,
                "title": f.filename,
                "key": f"file-{f.id}-{int(time.time())}",  # unique per session
                "url": download_url,                        # DS downloads from here
                "permissions": {
                    "edit": True,
                    "download": True,
                    "print": True,
                    "comment": True,
                    "fillForms": True,
                    "review": True,
                },
            },
            "editorConfig": {
                "callbackUrl": callback_url,
                "lang": "en",
                "mode": "edit",
                "user": {"id": user_id, "name": user_name},
            },
        }

        # If JWT is enabled on DS, include signed token of the config
        secret = settings.ONLYOFFICE["JWT_SECRET"]
        token = jwt.encode({"payload": cfg, "iat": int(time.time()), "exp": int(time.time()) + 300},
                           secret, algorithm="HS256")
        cfg["token"] = token

        return Response({
            "docServerApiJs": doc_api_js,
            "config": cfg,
        }, status=200)



class OnlyOfficeCreateDocxView(APIView):
    authentication_classes = [OAuth2Authentication]
    permission_classes = [TokenHasReadWriteScope]

    @swagger_auto_schema(
        operation_description="Create a blank DOCX and register it like uploads do.",
        tags=["OnlyOffice"],
        manual_parameters=[
            openapi.Parameter("project_id", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=True),
            openapi.Parameter("service_id", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=True),
            openapi.Parameter("title", openapi.IN_QUERY, type=openapi.TYPE_STRING, required=False),
        ],
        responses={201: "Created", 400: "Bad Request"},
    )
    def post(self, request):
        client_id = request.headers.get("X-Client-ID")
        user = get_object_or_404(User, id=1) if not getattr(request, "user", None) else request.user  # adapt to your auth
        project_id = request.query_params.get("project_id")
        service_id = request.query_params.get("service_id")
        title = (request.query_params.get("title") or "Untitled.docx").strip()
        if not (project_id and service_id):
            return Response({"error": "Missing project_id or service_id"}, status=400)

        # Save alongside your normal structure (same as your upload view convention)
        timestamp = time.strftime("%Y%m%d%H%M%S")
        # base_dir = os.path.join(
        #     settings.MEDIA_ROOT, "uploads",
        media_root = getattr(settings, "MEDIA_ROOT", "") or "/app/media"
        base_dir = os.path.join(
            media_root, "uploads",
            request.headers.get("X-Client-ID","client"),
            str(user.id), project_id, service_id, timestamp[:8]
        )
        os.makedirs(base_dir, exist_ok=True)
        out_path = os.path.join(base_dir, f"{timestamp[-6:]}_{title if title.endswith('.docx') else title + '.docx'}")

        # Create a blank docx with a first paragraph
        doc = DocxDocument()
        doc.add_paragraph(" ")
        doc.save(out_path)

        # Register (same pattern as your upload code)
        # with open(out_path, "rb") as fh:
        #    md5 = hashlib.md5(fh.read()).hexdigest()
       
        md5 = file_md5(out_path)

        storage = Storage.objects.create(
            user=user,
            content_type=ContentType.objects.get_for_model(Run),
            upload_storage_location=out_path,
        )
        f = File.objects.create(
            run=None,
            storage=storage,
            filename=os.path.basename(out_path),
            filepath=out_path,
            file_size=os.path.getsize(out_path),
            file_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            md5_hash=md5,
            user=user,
            project_id=project_id,
            service_id=service_id,
            extension="docx",
        )

        return Response({"file_id": f.id, "filename": f.filename}, status=201)

