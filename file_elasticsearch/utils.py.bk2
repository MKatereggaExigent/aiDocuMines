# file_elasticsearch/utils.py

from elasticsearch_dsl import Search, Q
from core.elastic_indexes import FileIndex
from core.utils import extract_document_text
from document_operations.utils import get_user_accessible_file_ids

def delete_index():
    FileIndex._index.delete(ignore=404)

def create_index():
    FileIndex.init()

def index_file(file_instance):
    content_text = extract_document_text(file_instance.filepath)
    doc = FileIndex(
        meta={"id": str(file_instance.id)},
        id=str(file_instance.id),
        filename=file_instance.filename,
        filepath=file_instance.filepath,
        file_size=file_instance.file_size,
        status=file_instance.status,
        project_id=file_instance.project_id,
        service_id=file_instance.service_id,
        created_at=file_instance.created_at,
        updated_at=file_instance.updated_at,
        md5_hash=file_instance.md5_hash,
        user_id=file_instance.user_id if file_instance.user_id else None,
        content=content_text,
    )
    doc.save()

def force_reindex():
    from core.models import File
    delete_index()
    create_index()
    for f in File.objects.all():
        index_file(f)

def _tenant_q(user, accessible_ids=None):
    """
    Return a bool-should filter:
      (user_id == me) OR (doc _id in my accessible file ids)
    """
    if accessible_ids is None:
        accessible_ids = get_user_accessible_file_ids(user)

    id_values = [str(i) for i in accessible_ids]  # ES ids are strings
    shoulds = [Q("term", user_id=user.id)]
    if id_values:
        shoulds.append(Q("ids", values=id_values))

    return Q("bool", should=shoulds, minimum_should_match=1)

def basic_search(query, scope="both", user=None, accessible_ids=None):
    if not query:
        return []

    s = Search(index="files")
    if user is not None:
        s = s.filter(_tenant_q(user, accessible_ids))

    if scope == "filename":
        s = s.query("multi_match", query=query, fields=["filename", "filepath"])
    elif scope == "content":
        s = s.query("match", content=query)
    else:  # both
        s = s.query("multi_match", query=query, fields=["filename", "filepath", "content"])

    # Optional: avoid returning full content payloads
    # s = s.source(excludes=["content"])
    # s = s.highlight("content", fragment_size=160, number_of_fragments=1)

    return s.execute()

def advanced_search(must=None, filter=None, search_in=None, user=None, accessible_ids=None):
    must = must or []
    filter = filter or []
    search_in = search_in or ["filename", "content"]

    # Build must clauses
    must_clauses = []
    for clause in must:
        field = clause["field"]
        value = clause["value"]
        if field == "content":
            must_clauses.append({"match": {"content": value}})
        else:
            must_clauses.append({"wildcard": {field: {"value": value, "case_insensitive": True}}})

    filter_clauses = []
    for f in filter:
        filter_clauses.append({"term": {f["field"]: f["value"]}})

    body = {"query": {"bool": {"must": must_clauses, "filter": filter_clauses}}}
    s = FileIndex.search().update_from_dict(body)

    if user is not None:
        s = s.filter(_tenant_q(user, accessible_ids))

    # Optional: field trimming / highlighting
    # s = s.source(excludes=["content"])
    # s = s.highlight("content", fragment_size=160, number_of_fragments=1)

    return s.execute()

